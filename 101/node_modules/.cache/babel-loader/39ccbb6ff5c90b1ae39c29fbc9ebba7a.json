{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport * as React from \"react\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { __use, useDeepMemo } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nexport function useSuspenseQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n      variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n      queryKey = _a === void 0 ? [] : _a;\n\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n\n  var _b = React.useState(function () {\n    return new Map([[queryRef.key, queryRef.promise]]);\n  }),\n      promiseCache = _b[0],\n      setPromiseCache = _b[1];\n\n  var promise = promiseCache.get(queryRef.key);\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  if (!promise) {\n    promise = queryRef.promise;\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(function () {\n    var dispose = queryRef.retain();\n    var removeListener = queryRef.listen(function (promise) {\n      setPromiseCache(function (promiseCache) {\n        return new Map(promiseCache).set(queryRef.key, promise);\n      });\n    });\n    return function () {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n  var skipResult = React.useMemo(function () {\n    var error = toApolloError(queryRef.result);\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error: error\n    };\n  }, [queryRef.result]);\n  var result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setPromiseCache(function (previousPromiseCache) {\n      return new Map(previousPromiseCache).set(queryRef.key, queryRef.promise);\n    });\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setPromiseCache(function (previousPromiseCache) {\n      return new Map(previousPromiseCache).set(queryRef.key, queryRef.promise);\n    });\n    return promise;\n  }, [queryRef]);\n  var subscribeToMore = React.useCallback(function (options) {\n    return queryRef.observable.subscribeToMore(options);\n  }, [queryRef]);\n  return React.useMemo(function () {\n    return {\n      client: client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore: fetchMore,\n      refetch: refetch,\n      subscribeToMore: subscribeToMore\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options) {\n  var query = options.query,\n      fetchPolicy = options.fetchPolicy,\n      returnPartialData = options.returnPartialData;\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(fetchPolicy) {\n  if (fetchPolicy === void 0) {\n    fetchPolicy = \"cache-first\";\n  }\n\n  var supportedFetchPolicies = [\"cache-first\", \"network-only\", \"no-cache\", \"cache-and-network\"];\n  invariant(supportedFetchPolicies.includes(fetchPolicy), 56, fetchPolicy);\n}\n\nfunction validatePartialDataReturn(fetchPolicy, returnPartialData) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    globalThis.__DEV__ !== false && invariant.warn(57);\n  }\n}\n\nexport function toApolloError(result) {\n  return isNonEmptyArray(result.errors) ? new ApolloError({\n    graphQLErrors: result.errors\n  }) : result.error;\n}\nexport function useWatchQueryOptions(_a) {\n  var client = _a.client,\n      query = _a.query,\n      options = _a.options;\n  return useDeepMemo(function () {\n    var _a;\n\n    if (options === skipToken) {\n      return {\n        query: query,\n        fetchPolicy: \"standby\"\n      };\n    }\n\n    var fetchPolicy = options.fetchPolicy || ((_a = client.defaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || \"cache-first\";\n\n    var watchQueryOptions = __assign(__assign({}, options), {\n      fetchPolicy: fetchPolicy,\n      query: query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0\n    });\n\n    if (globalThis.__DEV__ !== false) {\n      validateOptions(watchQueryOptions);\n    } // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n\n\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}","map":{"version":3,"sources":["../../../src/react/hooks/useSuspenseQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey } from \"../cache/types.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: TData;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: TData,\n      options: {\n        fetchMoreResult: TData;\n        variables: TVariables;\n      }\n    ) => TData;\n  }\n) => Promise<ApolloQueryResult<TData>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ?\n    TOptions[\"skip\"] extends boolean ?\n      DeepPartial<TData> | undefined\n    : DeepPartial<TData>\n  : TOptions[\"skip\"] extends boolean ? TData | undefined\n  : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  const [promiseCache, setPromiseCache] = React.useState(\n    () => new Map([[queryRef.key, queryRef.promise]])\n  );\n\n  let promise = promiseCache.get(queryRef.key);\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  if (!promise) {\n    promise = queryRef.promise;\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, promise)\n      );\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore = React.useCallback(\n    ((options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setPromiseCache((previousPromiseCache) =>\n        new Map(previousPromiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    }) satisfies FetchMoreFunction<\n      unknown,\n      OperationVariables\n    > as FetchMoreFunction<TData | undefined, TVariables>,\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setPromiseCache((previousPromiseCache) =>\n        new Map(previousPromiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore: SubscribeToMoreFunction<\n    TData | undefined,\n    TVariables\n  > = React.useCallback(\n    (options) => queryRef.observable.subscribeToMore(options),\n    [queryRef]\n  );\n\n  return React.useMemo<\n    UseSuspenseQueryResult<TData | undefined, TVariables>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors) ?\n      new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}