{"ast":null,"code":"import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n\n};\nexport function dep(options) {\n  const depsByKey = new Map();\n  const subscribe = options && options.subscribe;\n\n  function depend(key) {\n    const parent = parentEntrySlot.getValue();\n\n    if (parent) {\n      let dep = depsByKey.get(key);\n\n      if (!dep) {\n        depsByKey.set(key, dep = new Set());\n      }\n\n      parent.dependOn(dep);\n\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(key, entryMethodName) {\n    const dep = depsByKey.get(key);\n\n    if (dep) {\n      const m = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\"; // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend;\n}","map":{"version":3,"sources":["../src/dep.ts"],"names":[],"mappings":"AAEA,SAAS,eAAT,QAAgC,cAAhC;AACA,SACE,cADF,EAGE,gBAHF,EAIE,YAJF,QAKQ,cALR;AAQA,MAAM,YAAY,GAAG;AACnB,EAAA,QAAQ,EAAE,IADS;AAEnB,EAAA,OAAO,EAAE,IAFU;AAGnB,EAAA,MAAM,EAAE,IAHW,CAGH;;AAHG,CAArB;AAeA,OAAM,SAAU,GAAV,CAAoB,OAApB,EAEL;AACC,QAAM,SAAS,GAAG,IAAI,GAAJ,EAAlB;AACA,QAAM,SAAS,GAAG,OAAO,IAAI,OAAO,CAAC,SAArC;;AAEA,WAAS,MAAT,CAAgB,GAAhB,EAAyB;AACvB,UAAM,MAAM,GAAG,eAAe,CAAC,QAAhB,EAAf;;AACA,QAAI,MAAJ,EAAY;AACV,UAAI,GAAG,GAAG,SAAS,CAAC,GAAV,CAAc,GAAd,CAAV;;AACA,UAAI,CAAC,GAAL,EAAU;AACR,QAAA,SAAS,CAAC,GAAV,CAAc,GAAd,EAAmB,GAAG,GAAG,IAAI,GAAJ,EAAzB;AACD;;AACD,MAAA,MAAM,CAAC,QAAP,CAAgB,GAAhB;;AACA,UAAI,OAAO,SAAP,KAAqB,UAAzB,EAAqC;AACnC,QAAA,gBAAgB,CAAC,GAAD,CAAhB;AACA,QAAA,GAAG,CAAC,WAAJ,GAAkB,SAAS,CAAC,GAAD,CAA3B;AACD;AACF;AACF;;AAED,EAAA,MAAM,CAAC,KAAP,GAAe,SAAS,KAAT,CACb,GADa,EAEb,eAFa,EAEoB;AAEjC,UAAM,GAAG,GAAG,SAAS,CAAC,GAAV,CAAc,GAAd,CAAZ;;AACA,QAAI,GAAJ,EAAS;AACP,YAAM,CAAC,GACL,eAAe,IACf,cAAc,CAAC,IAAf,CAAoB,YAApB,EAAkC,eAAlC,CAFyB,GAGvB,eAHuB,GAGL,UAHtB,CADO,CAKP;AACA;AACA;;AACA,MAAA,YAAY,CAAC,GAAD,CAAZ,CAAkB,OAAlB,CAA0B,KAAK,IAAI,KAAK,CAAC,CAAD,CAAL,EAAnC;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,GAAjB;AACA,MAAA,gBAAgB,CAAC,GAAD,CAAhB;AACD;AACF,GAjBD;;AAmBA,SAAO,MAAP;AACD","sourceRoot":"","sourcesContent":["import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet, } from \"./helpers.js\";\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(entry => entry[m]());\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n//# sourceMappingURL=dep.js.map"]},"metadata":{},"sourceType":"module"}