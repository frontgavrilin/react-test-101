{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null); // Useful for processing arguments objects as well as arrays.\n\n\nconst {\n  forEach,\n  slice\n} = Array.prototype;\nconst {\n  hasOwnProperty\n} = Object.prototype;\nexport class Trie {\n  constructor(weakness = true, makeData = defaultMakeData) {\n    this.weakness = weakness;\n    this.makeData = makeData;\n  }\n\n  lookup() {\n    return this.lookupArray(arguments);\n  }\n\n  lookupArray(array) {\n    let node = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\") ? node.data : node.data = this.makeData(slice.call(array));\n  }\n\n  peek() {\n    return this.peekArray(arguments);\n  }\n\n  peekArray(array) {\n    let node = this;\n\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = node.mapFor(array[i], false);\n      node = map && map.get(array[i]);\n    }\n\n    return node && node.data;\n  }\n\n  remove() {\n    return this.removeArray(arguments);\n  }\n\n  removeArray(array) {\n    let data;\n\n    if (array.length) {\n      const head = array[0];\n      const map = this.mapFor(head, false);\n      const child = map && map.get(head);\n\n      if (child) {\n        data = child.removeArray(slice.call(array, 1));\n\n        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n          map.delete(head);\n        }\n      }\n    } else {\n      data = this.data;\n      delete this.data;\n    }\n\n    return data;\n  }\n\n  getChildTrie(key) {\n    const map = this.mapFor(key, true);\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n    return child;\n  }\n\n  mapFor(key, create) {\n    return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = new WeakMap() : void 0) : this.strong || (create ? this.strong = new Map() : void 0);\n  }\n\n}\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n\n    case \"function\":\n      return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nexport class Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup() {\n        return this.lookupArray(arguments);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        return this.peekArray(arguments);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = node.mapFor(array[i], false);\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    remove() {\n        return this.removeArray(arguments);\n    }\n    removeArray(array) {\n        let data;\n        if (array.length) {\n            const head = array[0];\n            const map = this.mapFor(head, false);\n            const child = map && map.get(head);\n            if (child) {\n                data = child.removeArray(slice.call(array, 1));\n                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n                    map.delete(head);\n                }\n            }\n        }\n        else {\n            data = this.data;\n            delete this.data;\n        }\n        return data;\n    }\n    getChildTrie(key) {\n        const map = this.mapFor(key, true);\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    mapFor(key, create) {\n        return this.weakness && isObjRef(key)\n            ? this.weak || (create ? this.weak = new WeakMap : void 0)\n            : this.strong || (create ? this.strong = new Map : void 0);\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}