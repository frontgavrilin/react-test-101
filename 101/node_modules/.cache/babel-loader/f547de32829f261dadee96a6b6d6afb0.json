{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport * as React from \"react\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapQueryRef } from \"../cache/QueryReference.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nexport function useBackgroundQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n      variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n      queryKey = _a === void 0 ? [] : _a; // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n\n  var didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current || (didFetchResult.current = fetchPolicy !== \"standby\");\n\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n\n  var _b = React.useState(function () {\n    return new Map([[queryRef.key, queryRef.promise]]);\n  }),\n      promiseCache = _b[0],\n      setPromiseCache = _b[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    var promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(function () {\n    return queryRef.retain();\n  }, [queryRef]);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setPromiseCache(function (promiseCache) {\n      return new Map(promiseCache).set(queryRef.key, queryRef.promise);\n    });\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setPromiseCache(function (promiseCache) {\n      return new Map(promiseCache).set(queryRef.key, queryRef.promise);\n    });\n    return promise;\n  }, [queryRef]);\n  queryRef.promiseCache = promiseCache;\n  var wrappedQueryRef = React.useMemo(function () {\n    return wrapQueryRef(queryRef);\n  }, [queryRef]);\n  return [didFetchResult.current ? wrappedQueryRef : void 0, {\n    fetchMore: fetchMore,\n    refetch: refetch\n  }];\n}","map":{"version":3,"sources":["../../../src/react/hooks/useBackgroundQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport type {\n  DocumentNode,\n  FetchMoreQueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport type { BackgroundQueryHookOptions, NoInfer } from \"../types/types.js\";\nimport { __use } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreFunction, RefetchFunction } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport type { CacheKey } from \"../cache/types.js\";\nimport type { SkipToken } from \"./constants.js\";\n\nexport type UseBackgroundQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  refetch: RefetchFunction<TData, TVariables>;\n};\n\ntype BackgroundQueryHookOptionsNoInfer<\n  TData,\n  TVariables extends OperationVariables,\n> = BackgroundQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>;\n\nexport function useBackgroundQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<BackgroundQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & TOptions\n): [\n  (\n    | QueryReference<\n        TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n          TOptions[\"returnPartialData\"] extends true ?\n            DeepPartial<TData> | undefined\n          : TData | undefined\n        : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n        : TData\n      >\n    | (TOptions[\"skip\"] extends boolean ? undefined : never)\n  ),\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<DeepPartial<TData> | undefined>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<TData | undefined>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n  }\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [QueryReference<TData>, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n        returnPartialData: true;\n      })\n): [\n  QueryReference<DeepPartial<TData>> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables> = Object.create(null)\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions as WatchQueryOptions<any, any>)\n  );\n\n  const [promiseCache, setPromiseCache] = React.useState(\n    () => new Map([[queryRef.key, queryRef.promise]])\n  );\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(() => queryRef.retain(), [queryRef]);\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options as FetchMoreQueryOptions<any>);\n\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  queryRef.promiseCache = promiseCache;\n\n  const wrappedQueryRef = React.useMemo(\n    () => wrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    { fetchMore, refetch },\n  ];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}