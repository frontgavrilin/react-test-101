{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false; // Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\n\nimport { mergeOptions } from \"../utilities/index.js\";\nexport { mergeOptions };\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an {@link ApolloLink} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\n\nvar ApolloClient =\n/** @class */\nfunction () {\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  function ApolloClient(options) {\n    var _this = this;\n\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n\n    if (!options.cache) {\n      throw newInvariantError(15);\n    }\n\n    var uri = options.uri,\n        credentials = options.credentials,\n        headers = options.headers,\n        cache = options.cache,\n        documentTransform = options.documentTransform,\n        _a = options.ssrMode,\n        ssrMode = _a === void 0 ? false : _a,\n        _b = options.ssrForceFetchDelay,\n        ssrForceFetchDelay = _b === void 0 ? 0 : _b,\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n    // onBroadcast in queryManager.broadcastQueries to enable browser\n    // devtools, but disable them by default in production.\n    _c = options.connectToDevTools,\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n    // onBroadcast in queryManager.broadcastQueries to enable browser\n    // devtools, but disable them by default in production.\n    connectToDevTools = _c === void 0 ? typeof window === \"object\" && !window.__APOLLO_CLIENT__ && globalThis.__DEV__ !== false : _c,\n        _d = options.queryDeduplication,\n        queryDeduplication = _d === void 0 ? true : _d,\n        defaultOptions = options.defaultOptions,\n        _e = options.assumeImmutableResults,\n        assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e,\n        resolvers = options.resolvers,\n        typeDefs = options.typeDefs,\n        fragmentMatcher = options.fragmentMatcher,\n        clientAwarenessName = options.name,\n        clientAwarenessVersion = options.version;\n    var link = options.link;\n\n    if (!link) {\n      link = uri ? new HttpLink({\n        uri: uri,\n        credentials: credentials,\n        headers: headers\n      }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      documentTransform: documentTransform,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName,\n        version: clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: connectToDevTools ? function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.getQueryStore(),\n              mutations: _this.queryManager.mutationStore || {}\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      } : void 0\n    });\n    if (connectToDevTools) this.connectToDevTools();\n  }\n\n  ApolloClient.prototype.connectToDevTools = function () {\n    if (typeof window === \"object\") {\n      var windowWithDevTools = window;\n      var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n      (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n      windowWithDevTools.__APOLLO_CLIENT__ = this;\n    }\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n\n\n    if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n      hasSuggestedDevtools = true;\n      setTimeout(function () {\n        if (typeof window !== \"undefined\" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n          var nav = window.navigator;\n          var ua = nav && nav.userAgent;\n          var url = void 0;\n\n          if (typeof ua === \"string\") {\n            if (ua.indexOf(\"Chrome/\") > -1) {\n              url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n            } else if (ua.indexOf(\"Firefox/\") > -1) {\n              url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n            }\n          }\n\n          if (url) {\n            globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n          }\n        }\n      }, 10000);\n    }\n  };\n\n  Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n    /**\n     * The `DocumentTransform` used to modify GraphQL documents before a request\n     * is made. If a custom `DocumentTransform` is not provided, this will be the\n     * default document transform.\n     */\n    get: function () {\n      return this.queryManager.documentTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n\n\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    } // XXX Overwriting options is probably not the best way to do this long term...\n\n\n    if (this.disableNetworkFetches && (options.fetchPolicy === \"network-only\" || options.fetchPolicy === \"cache-and-network\")) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n\n    return this.queryManager.watchQuery(options);\n  };\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n\n\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(options.fetchPolicy !== \"cache-and-network\", 16);\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n\n    return this.queryManager.query(options);\n  };\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n\n\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n\n    return this.queryManager.mutate(options);\n  };\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n\n\n  ApolloClient.prototype.subscribe = function (options) {\n    return this.queryManager.startGraphQLSubscription(options);\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n\n\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return this.cache.readQuery(options, optimistic);\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n\n\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return this.cache.readFragment(options, optimistic);\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n\n\n  ApolloClient.prototype.writeQuery = function (options) {\n    var ref = this.cache.writeQuery(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n\n\n  ApolloClient.prototype.writeFragment = function (options) {\n    var ref = this.cache.writeFragment(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  };\n\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n\n\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: false\n      });\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n\n\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: true\n      });\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n\n\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n\n\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n\n\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n\n\n  ApolloClient.prototype.refetchQueries = function (options) {\n    var map = this.queryManager.refetchQueries(options);\n    var queries = [];\n    var results = [];\n    map.forEach(function (result, obsQuery) {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n    var result = Promise.all(results); // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n\n    result.queries = queries;\n    result.results = results; // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n\n    result.catch(function (error) {\n      globalThis.__DEV__ !== false && invariant.debug(17, error);\n    });\n    return result;\n  };\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n\n\n  ApolloClient.prototype.getObservableQueries = function (include) {\n    if (include === void 0) {\n      include = \"active\";\n    }\n\n    return this.queryManager.getObservableQueries(include);\n  };\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n\n\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n\n\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n  /**\n   * Add additional local resolvers.\n   */\n\n\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n  /**\n   * Set (override existing) local resolvers.\n   */\n\n\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n  /**\n   * Get all registered local resolvers.\n   */\n\n\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n  /**\n   * Set a custom local state fragment matcher.\n   */\n\n\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n\n\n  ApolloClient.prototype.setLink = function (newLink) {\n    this.link = this.queryManager.link = newLink;\n  };\n\n  return ApolloClient;\n}();\n\nexport { ApolloClient };","map":{"version":3,"sources":["../../src/core/ApolloClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { ExecutionResult, DocumentNode } from \"graphql\";\n\nimport type { FetchResult, GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform, Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  uri?: string | UriFunction;\n  credentials?: string;\n  headers?: Record<string, string>;\n  /**\n   * You can provide an {@link ApolloLink} instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react//performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   */\n  version?: string;\n  documentTransform?: DocumentTransform;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an {@link ApolloLink} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools = typeof window === \"object\" &&\n        !(window as any).__APOLLO_CLIENT__ &&\n        __DEV__,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        connectToDevTools ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (connectToDevTools) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"object\") {\n      type DevToolsConnector = {\n        push(client: ApolloClient<any>): void;\n      };\n      const windowWithDevTools = window as Window & {\n        [devtoolsSymbol]?: DevToolsConnector;\n        __APOLLO_CLIENT__?: ApolloClient<any>;\n      };\n      const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n      (windowWithDevTools[devtoolsSymbol] =\n        windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n        this\n      );\n      windowWithDevTools.__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      setTimeout(() => {\n        if (\n          typeof window !== \"undefined\" &&\n          window.document &&\n          window.top === window.self &&\n          !(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__\n        ) {\n          const nav = window.navigator;\n          const ua = nav && nav.userAgent;\n          let url: string | undefined;\n          if (typeof ua === \"string\") {\n            if (ua.indexOf(\"Chrome/\") > -1) {\n              url =\n                \"https://chrome.google.com/webstore/detail/\" +\n                \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n            } else if (ua.indexOf(\"Firefox/\") > -1) {\n              url =\n                \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n            }\n          }\n          if (url) {\n            invariant.log(\n              \"Download the Apollo DevTools for a better development \" +\n                \"experience: %s\",\n              url\n            );\n          }\n        }\n      }, 10000);\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: QueryOptions<TVariables, T>): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<FetchResult<TData>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: SubscriptionOptions<TVariables, T>): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}