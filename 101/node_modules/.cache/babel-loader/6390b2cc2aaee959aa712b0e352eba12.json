{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n  var stateRef = React.useRef();\n\n  if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n\n  var state = stateRef.current; // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n\n  state.forceUpdateState = React.useReducer(function (tick) {\n    return tick + 1;\n  }, 0)[1];\n  return state;\n}\n\nvar InternalState =\n/** @class */\nfunction () {\n  function InternalState(client, query, previous) {\n    var _this = this;\n\n    this.client = client;\n    this.query = query;\n    /**\n     * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n     * whenever it is available and reset to `forceUpdateState` when it isn't.\n     */\n\n    this.forceUpdate = function () {\n      return _this.forceUpdateState();\n    };\n\n    this.ssrDisabledResult = maybeDeepFreeze({\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    });\n    this.skipStandbyResult = maybeDeepFreeze({\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    }); // This cache allows the referential stability of this.result (as returned by\n    // getCurrentResult) to translate into referential stability of the resulting\n    // QueryResult object returned by toQueryResult.\n\n    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n    verifyDocumentType(query, DocumentType.Query); // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n\n    var previousResult = previous && previous.result;\n    var previousData = previousResult && previousResult.data;\n\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n\n\n  InternalState.prototype.forceUpdateState = function () {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    globalThis.__DEV__ !== false && invariant.warn(50);\n  };\n\n  InternalState.prototype.executeQuery = function (options) {\n    var _this = this;\n\n    var _a;\n\n    if (options.query) {\n      Object.assign(this, {\n        query: options.query\n      });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions()); // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n\n    this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n    return new Promise(function (resolve) {\n      var result; // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n\n      concast.subscribe({\n        next: function (value) {\n          result = value;\n        },\n        error: function () {\n          resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\n        },\n        complete: function () {\n          resolve(_this.toQueryResult(result));\n        }\n      });\n    });\n  }; // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n\n\n  InternalState.prototype.useQuery = function (options) {\n    var _this = this; // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n\n\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n    this.useOptions(options);\n    var obsQuery = this.useObservableQuery();\n    var result = useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n      if (_this.renderPromises) {\n        return function () {};\n      }\n\n      _this.forceUpdate = handleStoreChange;\n\n      var onNext = function () {\n        var previousResult = _this.result; // We use `getCurrentResult()` instead of the onNext argument because\n        // the values differ slightly. Specifically, loading results will have\n        // an empty object for data instead of `undefined` for some reason.\n\n        var result = obsQuery.getCurrentResult(); // Make sure we're not attempting to re-render similar results\n\n        if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n          return;\n        }\n\n        _this.setResult(result);\n      };\n\n      var onError = function (error) {\n        subscription.unsubscribe();\n        subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n        if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n          // The error is not a GraphQL error\n          throw error;\n        }\n\n        var previousResult = _this.result;\n\n        if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n          _this.setResult({\n            data: previousResult && previousResult.data,\n            error: error,\n            loading: false,\n            networkStatus: NetworkStatus.error\n          });\n        }\n      };\n\n      var subscription = obsQuery.subscribe(onNext, onError); // Do the \"unsubscribe\" with a short delay.\n      // This way, an existing subscription can be reused without an additional\n      // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n      // happen in very fast succession.\n\n      return function () {\n        setTimeout(function () {\n          return subscription.unsubscribe();\n        });\n\n        _this.forceUpdate = function () {\n          return _this.forceUpdateState();\n        };\n      };\n    }, [// We memoize the subscribe function using useCallback and the following\n    // dependency keys, because the subscribe function reference is all that\n    // useSyncExternalStore uses internally as a dependency key for the\n    // useEffect ultimately responsible for the subscription, so we are\n    // effectively passing this dependency array to that useEffect buried\n    // inside useSyncExternalStore, as desired.\n    obsQuery, this.renderPromises, this.client.disableNetworkFetches]), function () {\n      return _this.getCurrentResult();\n    }, function () {\n      return _this.getCurrentResult();\n    }); // TODO Remove this method when we remove support for options.partialRefetch.\n\n    this.unsafeHandlePartialRefetch(result);\n    return this.toQueryResult(result);\n  };\n\n  InternalState.prototype.useOptions = function (options) {\n    var _a;\n\n    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options); // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n\n    var currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions()); // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n      }\n    } // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n\n\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === \"standby\") {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {\n      this.result = void 0;\n    }\n  };\n\n  InternalState.prototype.getObsQueryOptions = function () {\n    var toMerge = [];\n    var globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    } // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n\n\n    toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n  }; // A function to massage options before passing them to ObservableQuery.\n\n\n  InternalState.prototype.createWatchQueryOptions = function (_a) {\n    var _b;\n\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var skip = _a.skip,\n        ssr = _a.ssr,\n        onCompleted = _a.onCompleted,\n        onError = _a.onError,\n        defaultOptions = _a.defaultOptions,\n        // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]); // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n\n\n    var watchQueryOptions = Object.assign(otherOptions, {\n      query: this.query\n    });\n\n    if (this.renderPromises && (watchQueryOptions.fetchPolicy === \"network-only\" || watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {};\n    }\n\n    if (skip) {\n      var _c = watchQueryOptions.fetchPolicy,\n          fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c,\n          _d = watchQueryOptions.initialFetchPolicy,\n          initialFetchPolicy = _d === void 0 ? fetchPolicy : _d; // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy: initialFetchPolicy,\n        fetchPolicy: \"standby\"\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  };\n\n  InternalState.prototype.getDefaultFetchPolicy = function () {\n    var _a, _b;\n\n    return ((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"cache-first\";\n  }; // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n\n\n  InternalState.prototype.onCompleted = function (data) {};\n\n  InternalState.prototype.onError = function (error) {};\n\n  InternalState.prototype.useObservableQuery = function () {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || // Reuse this.observable if possible (and not SSR)\n    this.client.watchQuery(this.getObsQueryOptions());\n    this.obsQueryFields = React.useMemo(function () {\n      return {\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n      };\n    }, [obsQuery]);\n    var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  };\n\n  InternalState.prototype.setResult = function (nextResult) {\n    var previousResult = this.result;\n\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n\n    this.result = nextResult; // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  };\n\n  InternalState.prototype.handleErrorOrCompleted = function (result, previousResult) {\n    var _this = this;\n\n    if (!result.loading) {\n      var error_1 = this.toApolloError(result); // wait a tick in case we are in the middle of rendering a component\n\n      Promise.resolve().then(function () {\n        if (error_1) {\n          _this.onError(error_1);\n        } else if (result.data && (previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus) !== result.networkStatus && result.networkStatus === NetworkStatus.ready) {\n          _this.onCompleted(result.data);\n        }\n      }).catch(function (error) {\n        globalThis.__DEV__ !== false && invariant.warn(error);\n      });\n    }\n  };\n\n  InternalState.prototype.toApolloError = function (result) {\n    return isNonEmptyArray(result.errors) ? new ApolloError({\n      graphQLErrors: result.errors\n    }) : result.error;\n  };\n\n  InternalState.prototype.getCurrentResult = function () {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n    }\n\n    return this.result;\n  };\n\n  InternalState.prototype.toQueryResult = function (result) {\n    var queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    var data = result.data,\n        partial = result.partial,\n        resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n\n    this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({\n      data: data\n    }, resultWithoutPartial), this.obsQueryFields), {\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData\n    }));\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({\n        graphQLErrors: result.errors\n      });\n    }\n\n    return queryResult;\n  };\n\n  InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== \"cache-only\") {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      this.observable.refetch();\n    }\n  };\n\n  return InternalState;\n}();","map":{"version":3,"sources":["../../../src/react/hooks/useQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type { ApolloContextValue } from \"../context/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  canUseWeakMap,\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return useInternalState(useApolloClient(options.client), query).useQuery(\n    options\n  );\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>\n): InternalState<TData, TVariables> {\n  const stateRef = React.useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  state.forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  forceUpdateState() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\n      \"Calling default no-op implementation of InternalState#forceUpdate\"\n    );\n  }\n\n  /**\n   * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n   * whenever it is available and reset to `forceUpdateState` when it isn't.\n   */\n  forceUpdate = () => this.forceUpdateState();\n\n  executeQuery(\n    options: QueryHookOptions<TData, TVariables> & {\n      query?: DocumentNode;\n    }\n  ) {\n    if (options.query) {\n      Object.assign(this, { query: options.query });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        },\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      React.useCallback(\n        (handleStoreChange) => {\n          if (this.renderPromises) {\n            return () => {};\n          }\n\n          this.forceUpdate = handleStoreChange;\n\n          const onNext = () => {\n            const previousResult = this.result;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            const result = obsQuery.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (\n              previousResult &&\n              previousResult.loading === result.loading &&\n              previousResult.networkStatus === result.networkStatus &&\n              equal(previousResult.data, result.data)\n            ) {\n              return;\n            }\n\n            this.setResult(result);\n          };\n\n          const onError = (error: Error) => {\n            subscription.unsubscribe();\n            subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n              // The error is not a GraphQL error\n              throw error;\n            }\n\n            const previousResult = this.result;\n            if (\n              !previousResult ||\n              (previousResult && previousResult.loading) ||\n              !equal(error, previousResult.error)\n            ) {\n              this.setResult({\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              });\n            }\n          };\n\n          let subscription = obsQuery.subscribe(onNext, onError);\n\n          // Do the \"unsubscribe\" with a short delay.\n          // This way, an existing subscription can be reused without an additional\n          // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n          // happen in very fast succession.\n          return () => {\n            setTimeout(() => subscription.unsubscribe());\n            this.forceUpdate = () => this.forceUpdateState();\n          };\n        },\n        [\n          // We memoize the subscribe function using useCallback and the following\n          // dependency keys, because the subscribe function reference is all that\n          // useSyncExternalStore uses internally as a dependency key for the\n          // useEffect ultimately responsible for the subscription, so we are\n          // effectively passing this dependency array to that useEffect buried\n          // inside useSyncExternalStore, as desired.\n          obsQuery,\n          this.renderPromises,\n          this.client.disableNetworkFetches,\n        ]\n      ),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult()\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions!: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions!: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(options: QueryHookOptions<TData, TVariables>) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted =\n      options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === \"standby\"\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(\n      compact(\n        this.observable && this.observable.options,\n        this.watchQueryOptions\n      )\n    );\n\n    return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<\n    TVariables,\n    TData\n  > {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: \"standby\",\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable!: ObservableQuery<TData, TVariables>;\n  private obsQueryFields!: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = (this.observable =\n      (this.renderPromises &&\n        this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n      this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions()));\n\n    this.obsQueryFields = React.useMemo(\n      () => ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n      }),\n      [obsQuery]\n    );\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false || this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  }\n\n  private handleErrorOrCompleted(\n    result: ApolloQueryResult<TData>,\n    previousResult?: ApolloQueryResult<TData>\n  ) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve()\n        .then(() => {\n          if (error) {\n            this.onError(error);\n          } else if (\n            result.data &&\n            previousResult?.networkStatus !== result.networkStatus &&\n            result.networkStatus === NetworkStatus.ready\n          ) {\n            this.onCompleted(result.data);\n          }\n        })\n        .catch((error) => {\n          invariant.warn(error);\n        });\n    }\n  }\n\n  private toApolloError(\n    result: ApolloQueryResult<TData>\n  ): ApolloError | undefined {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n      : result.error;\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        (this.result = this.observable.getCurrentResult())\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(\n      result,\n      (queryResult = {\n        data, // Ensure always defined, even if result.data is missing.\n        ...resultWithoutPartial,\n        ...this.obsQueryFields,\n        client: this.client,\n        observable: this.observable,\n        variables: this.observable.variables,\n        called: !this.queryHookOptions.skip,\n        previousData: this.previousData,\n      })\n    );\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== \"cache-only\"\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}