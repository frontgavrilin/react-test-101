{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport { createFulfilledPromise, createRejectedPromise } from \"../../utilities/index.js\";\nvar QUERY_REFERENCE_SYMBOL = Symbol();\nexport function wrapQueryRef(internalQueryRef) {\n  var _a;\n\n  return _a = {}, _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a;\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nvar OBSERVED_CHANGED_OPTIONS = [\"canonizeResults\", \"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\n\nvar InternalQueryReference =\n/** @class */\nfunction () {\n  function InternalQueryReference(observable, options) {\n    var _this = this;\n\n    this.listeners = new Set();\n    this.status = \"loading\";\n    this.references = 0;\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable; // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    if (isNetworkRequestSettled(this.result.networkStatus) || this.result.data && (!this.result.partial || this.watchQueryOptions.returnPartialData)) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise(function (resolve, reject) {\n        _this.resolve = resolve;\n        _this.reject = reject;\n      });\n    }\n\n    this.subscription = observable.filter(function (_a) {\n      var data = _a.data;\n      return !equal(data, {});\n    }).subscribe({\n      next: this.handleNext,\n      error: this.handleError\n    }); // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n\n    var startDisposeTimer = function () {\n      var _a;\n\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    }; // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n\n\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  Object.defineProperty(InternalQueryReference.prototype, \"watchQueryOptions\", {\n    get: function () {\n      return this.observable.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InternalQueryReference.prototype.retain = function () {\n    var _this = this;\n\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      _this.references--; // Wait before fully disposing in case the app is running in strict mode.\n\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n\n  InternalQueryReference.prototype.didChangeOptions = function (watchQueryOptions) {\n    var _this = this;\n\n    return OBSERVED_CHANGED_OPTIONS.some(function (option) {\n      return !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);\n    });\n  };\n\n  InternalQueryReference.prototype.applyOptions = function (watchQueryOptions) {\n    var _a = this.watchQueryOptions,\n        currentFetchPolicy = _a.fetchPolicy,\n        currentCanonizeResults = _a.canonizeResults; // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  };\n\n  InternalQueryReference.prototype.listen = function (listener) {\n    var _this = this;\n\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n\n  InternalQueryReference.prototype.refetch = function (variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  };\n\n  InternalQueryReference.prototype.fetchMore = function (options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  };\n\n  InternalQueryReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n\n  InternalQueryReference.prototype.onDispose = function () {// noop. overridable by options\n  };\n\n  InternalQueryReference.prototype.handleNext = function (result) {\n    var _a;\n\n    switch (this.status) {\n      case \"loading\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n\n          this.status = \"idle\";\n          this.result = result;\n          (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);\n          break;\n        }\n\n      case \"idle\":\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data) {\n            return;\n          } // Maintain the last successful `data` value if the next result does not\n          // have one.\n\n\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n          break;\n        }\n    }\n  };\n\n  InternalQueryReference.prototype.handleError = function (error) {\n    var _a;\n\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);\n\n    switch (this.status) {\n      case \"loading\":\n        {\n          this.status = \"idle\";\n          (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n          break;\n        }\n\n      case \"idle\":\n        {\n          this.promise = createRejectedPromise(error);\n          this.deliver(this.promise);\n        }\n    }\n  };\n\n  InternalQueryReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n\n  InternalQueryReference.prototype.initiateFetch = function (returnedPromise) {\n    var _this = this;\n\n    this.status = \"loading\";\n    this.promise = new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    });\n    this.promise.catch(function () {}); // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n\n    returnedPromise.then(function (result) {\n      var _a;\n\n      if (_this.status === \"loading\") {\n        _this.status = \"idle\";\n        _this.result = result;\n        (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, result);\n      }\n    }).catch(function () {});\n    return returnedPromise;\n  };\n\n  return InternalQueryReference;\n}();\n\nexport { InternalQueryReference };","map":{"version":3,"sources":["../../../src/react/cache/QueryReference.ts"],"names":[],"mappings":"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","sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../utilities/index.js\";\nimport type { CacheKey } from \"./types.js\";\nimport type { useBackgroundQuery, useReadQuery } from \"../hooks/index.js\";\n\ntype Listener<TData> = (promise: Promise<ApolloQueryResult<TData>>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\n/**\n * A `QueryReference` is an opaque object returned by {@link useBackgroundQuery}.\n * A child component reading the `QueryReference` via {@link useReadQuery} will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown> {\n  [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n}\n\ninterface InternalQueryReferenceOptions {\n  key: CacheKey;\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData>(\n  internalQueryRef: InternalQueryReference<TData>\n): QueryReference<TData> {\n  return { [QUERY_REFERENCE_SYMBOL]: internalQueryRef };\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result: ApolloQueryResult<TData>;\n  public readonly key: CacheKey;\n  public readonly observable: ObservableQuery<TData>;\n\n  public promiseCache?: Map<CacheKey, Promise<ApolloQueryResult<TData>>>;\n  public promise: Promise<ApolloQueryResult<TData>>;\n\n  private subscription: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n  private status: \"idle\" | \"loading\" = \"loading\";\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n\n  constructor(\n    observable: ObservableQuery<TData>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    if (\n      isNetworkRequestSettled(this.result.networkStatus) ||\n      (this.result.data &&\n        (!this.result.partial || this.watchQueryOptions.returnPartialData))\n    ) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n    }\n\n    this.subscription = observable\n      .filter(({ data }) => !equal(data, {}))\n      .subscribe({\n        next: this.handleNext,\n        error: this.handleError,\n      });\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.status) {\n      case \"loading\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.status = \"idle\";\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      case \"idle\": {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (result.data === this.result.data) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.status) {\n      case \"loading\": {\n        this.status = \"idle\";\n        this.reject?.(error);\n        break;\n      }\n      case \"idle\": {\n        this.promise = createRejectedPromise(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: Promise<ApolloQueryResult<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.status = \"loading\";\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then((result) => {\n        if (this.status === \"loading\") {\n          this.status = \"idle\";\n          this.result = result;\n          this.resolve?.(result);\n        }\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}