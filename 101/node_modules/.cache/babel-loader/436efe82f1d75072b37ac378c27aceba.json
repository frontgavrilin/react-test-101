{"ast":null,"code":"function noop() {}\n\nconst defaultDispose = noop;\n\nconst _WeakRef = typeof WeakRef !== \"undefined\" ? WeakRef : function (value) {\n  return {\n    deref: () => value\n  };\n};\n\nconst _WeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\n\nconst _FinalizationRegistry = typeof FinalizationRegistry !== \"undefined\" ? FinalizationRegistry : function () {\n  return {\n    register: noop,\n    unregister: noop\n  };\n};\n\nconst finalizationBatchSize = 10024;\nexport class WeakCache {\n  constructor(max = Infinity, dispose = defaultDispose) {\n    this.max = max;\n    this.dispose = dispose;\n    this.map = new _WeakMap();\n    this.newest = null;\n    this.oldest = null;\n    this.unfinalizedNodes = new Set();\n    this.finalizationScheduled = false;\n    this.size = 0;\n\n    this.finalize = () => {\n      const iterator = this.unfinalizedNodes.values();\n\n      for (let i = 0; i < finalizationBatchSize; i++) {\n        const node = iterator.next().value;\n        if (!node) break;\n        this.unfinalizedNodes.delete(node);\n        const key = node.key;\n        delete node.key;\n        node.keyRef = new _WeakRef(key);\n        this.registry.register(key, node, node);\n      }\n\n      if (this.unfinalizedNodes.size > 0) {\n        queueMicrotask(this.finalize);\n      } else {\n        this.finalizationScheduled = false;\n      }\n    };\n\n    this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));\n  }\n\n  has(key) {\n    return this.map.has(key);\n  }\n\n  get(key) {\n    const node = this.getNode(key);\n    return node && node.value;\n  }\n\n  getNode(key) {\n    const node = this.map.get(key);\n\n    if (node && node !== this.newest) {\n      const {\n        older,\n        newer\n      } = node;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      node.older = this.newest;\n      node.older.newer = node;\n      node.newer = null;\n      this.newest = node;\n\n      if (node === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return node;\n  }\n\n  set(key, value) {\n    let node = this.getNode(key);\n\n    if (node) {\n      return node.value = value;\n    }\n\n    node = {\n      key,\n      value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = node;\n    }\n\n    this.newest = node;\n    this.oldest = this.oldest || node;\n    this.scheduleFinalization(node);\n    this.map.set(key, node);\n    this.size++;\n    return node.value;\n  }\n\n  clean() {\n    while (this.oldest && this.size > this.max) {\n      this.deleteNode(this.oldest);\n    }\n  }\n\n  deleteNode(node) {\n    if (node === this.newest) {\n      this.newest = node.older;\n    }\n\n    if (node === this.oldest) {\n      this.oldest = node.newer;\n    }\n\n    if (node.newer) {\n      node.newer.older = node.older;\n    }\n\n    if (node.older) {\n      node.older.newer = node.newer;\n    }\n\n    this.size--;\n    const key = node.key || node.keyRef && node.keyRef.deref();\n    this.dispose(node.value, key);\n\n    if (!node.keyRef) {\n      this.unfinalizedNodes.delete(node);\n    } else {\n      this.registry.unregister(node);\n    }\n\n    if (key) this.map.delete(key);\n  }\n\n  delete(key) {\n    const node = this.map.get(key);\n\n    if (node) {\n      this.deleteNode(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  scheduleFinalization(node) {\n    this.unfinalizedNodes.add(node);\n\n    if (!this.finalizationScheduled) {\n      this.finalizationScheduled = true;\n      queueMicrotask(this.finalize);\n    }\n  }\n\n}","map":{"version":3,"sources":["../src/weak.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["function noop() { }\nconst defaultDispose = noop;\nconst _WeakRef = typeof WeakRef !== \"undefined\"\n    ? WeakRef\n    : function (value) {\n        return { deref: () => value };\n    };\nconst _WeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\nconst _FinalizationRegistry = typeof FinalizationRegistry !== \"undefined\"\n    ? FinalizationRegistry\n    : function () {\n        return {\n            register: noop,\n            unregister: noop,\n        };\n    };\nconst finalizationBatchSize = 10024;\nexport class WeakCache {\n    constructor(max = Infinity, dispose = defaultDispose) {\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new _WeakMap();\n        this.newest = null;\n        this.oldest = null;\n        this.unfinalizedNodes = new Set();\n        this.finalizationScheduled = false;\n        this.size = 0;\n        this.finalize = () => {\n            const iterator = this.unfinalizedNodes.values();\n            for (let i = 0; i < finalizationBatchSize; i++) {\n                const node = iterator.next().value;\n                if (!node)\n                    break;\n                this.unfinalizedNodes.delete(node);\n                const key = node.key;\n                delete node.key;\n                node.keyRef = new _WeakRef(key);\n                this.registry.register(key, node, node);\n            }\n            if (this.unfinalizedNodes.size > 0) {\n                queueMicrotask(this.finalize);\n            }\n            else {\n                this.finalizationScheduled = false;\n            }\n        };\n        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return (node.value = value);\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest,\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.scheduleFinalization(node);\n        this.map.set(key, node);\n        this.size++;\n        return node.value;\n    }\n    clean() {\n        while (this.oldest && this.size > this.max) {\n            this.deleteNode(this.oldest);\n        }\n    }\n    deleteNode(node) {\n        if (node === this.newest) {\n            this.newest = node.older;\n        }\n        if (node === this.oldest) {\n            this.oldest = node.newer;\n        }\n        if (node.newer) {\n            node.newer.older = node.older;\n        }\n        if (node.older) {\n            node.older.newer = node.newer;\n        }\n        this.size--;\n        const key = node.key || (node.keyRef && node.keyRef.deref());\n        this.dispose(node.value, key);\n        if (!node.keyRef) {\n            this.unfinalizedNodes.delete(node);\n        }\n        else {\n            this.registry.unregister(node);\n        }\n        if (key)\n            this.map.delete(key);\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            this.deleteNode(node);\n            return true;\n        }\n        return false;\n    }\n    scheduleFinalization(node) {\n        this.unfinalizedNodes.add(node);\n        if (!this.finalizationScheduled) {\n            this.finalizationScheduled = true;\n            queueMicrotask(this.finalize);\n        }\n    }\n}\n//# sourceMappingURL=weak.js.map"]},"metadata":{},"sourceType":"module"}