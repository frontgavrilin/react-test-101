{"ast":null,"code":"import { invariant, newInvariantError } from \"../globals/index.js\";\nimport { valueToObjectRepresentation } from \"./storeUtils.js\"; // Checks the document for errors and throws an exception if there is an error.\n\nexport function checkDocument(doc) {\n  invariant(doc && doc.kind === \"Document\", 73);\n  var operations = doc.definitions.filter(function (d) {\n    return d.kind !== \"FragmentDefinition\";\n  }).map(function (definition) {\n    if (definition.kind !== \"OperationDefinition\") {\n      throw newInvariantError(74, definition.kind);\n    }\n\n    return definition;\n  });\n  invariant(operations.length <= 1, 75, operations.length);\n  return doc;\n}\nexport function getOperationDefinition(doc) {\n  checkDocument(doc);\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === \"OperationDefinition\";\n  })[0];\n}\nexport function getOperationName(doc) {\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === \"OperationDefinition\" && !!definition.name;\n  }).map(function (x) {\n    return x.name.value;\n  })[0] || null;\n} // Returns the FragmentDefinitions from a particular document as an array\n\nexport function getFragmentDefinitions(doc) {\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === \"FragmentDefinition\";\n  });\n}\nexport function getQueryDefinition(doc) {\n  var queryDef = getOperationDefinition(doc);\n  invariant(queryDef && queryDef.operation === \"query\", 76);\n  return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n  invariant(doc.kind === \"Document\", 77);\n  invariant(doc.definitions.length <= 1, 78);\n  var fragmentDef = doc.definitions[0];\n  invariant(fragmentDef.kind === \"FragmentDefinition\", 79);\n  return fragmentDef;\n}\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\n\nexport function getMainDefinition(queryDoc) {\n  checkDocument(queryDoc);\n  var fragmentDefinition;\n\n  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n    var definition = _a[_i];\n\n    if (definition.kind === \"OperationDefinition\") {\n      var operation = definition.operation;\n\n      if (operation === \"query\" || operation === \"mutation\" || operation === \"subscription\") {\n        return definition;\n      }\n    }\n\n    if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw newInvariantError(80);\n}\nexport function getDefaultValues(definition) {\n  var defaultValues = Object.create(null);\n  var defs = definition && definition.variableDefinitions;\n\n  if (defs && defs.length) {\n    defs.forEach(function (def) {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);\n      }\n    });\n  }\n\n  return defaultValues;\n}","map":{"version":3,"sources":["../../../src/utilities/graphql/getFromAST.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant, newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from \"graphql\";\n\nimport { valueToObjectRepresentation } from \"./storeUtils.js\";\n\ntype OperationDefinitionWithName = OperationDefinitionNode & {\n  name: NonNullable<OperationDefinitionNode[\"name\"]>;\n};\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === \"Document\",\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`\n  );\n\n  const operations = doc.definitions\n    .filter((d) => d.kind !== \"FragmentDefinition\")\n    .map((definition) => {\n      if (definition.kind !== \"OperationDefinition\") {\n        throw newInvariantError(\n          `Schema type definitions not allowed in queries. Found: \"%s\"`,\n          definition.kind\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains %s operations`,\n    operations.length\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    (definition): definition is OperationDefinitionNode =>\n      definition.kind === \"OperationDefinition\"\n  )[0];\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        (definition): definition is OperationDefinitionWithName =>\n          definition.kind === \"OperationDefinition\" && !!definition.name\n      )\n      .map((x) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    (definition): definition is FragmentDefinitionNode =>\n      definition.kind === \"FragmentDefinition\"\n  );\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc)!;\n\n  invariant(\n    queryDef && queryDef.operation === \"query\",\n    \"Must contain a query definition.\"\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === \"Document\",\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    \"Fragment must have exactly one definition.\"\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === \"FragmentDefinition\",\n    \"Must be a fragment definition.\"\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === \"OperationDefinition\") {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === \"query\" ||\n        operation === \"mutation\" ||\n        operation === \"subscription\"\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw newInvariantError(\n    \"Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.\"\n  );\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined\n): Record<string, any> {\n  const defaultValues = Object.create(null);\n  const defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach((def) => {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(\n          defaultValues,\n          def.variable.name,\n          def.defaultValue as ValueNode\n        );\n      }\n    });\n  }\n  return defaultValues;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}