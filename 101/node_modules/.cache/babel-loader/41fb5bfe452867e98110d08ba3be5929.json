{"ast":null,"code":"import * as React from \"react\";\nimport { unwrapQueryRef } from \"../cache/QueryReference.js\";\nimport { __use } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nexport function useReadQuery(queryRef) {\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  invariant(internalQueryRef.promiseCache, 51);\n  var promiseCache = internalQueryRef.promiseCache,\n      key = internalQueryRef.key;\n\n  if (!promiseCache.has(key)) {\n    promiseCache.set(key, internalQueryRef.promise);\n  }\n\n  var promise = useSyncExternalStore(React.useCallback(function (forceUpdate) {\n    return internalQueryRef.listen(function (promise) {\n      internalQueryRef.promiseCache.set(internalQueryRef.key, promise);\n      forceUpdate();\n    });\n  }, [internalQueryRef]), function () {\n    return promiseCache.get(key);\n  }, function () {\n    return promiseCache.get(key);\n  });\n\n  var result = __use(promise);\n\n  return React.useMemo(function () {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result)\n    };\n  }, [result]);\n}","map":{"version":3,"sources":["../../../src/react/hooks/useReadQuery.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,cAAT,QAA+B,4BAA/B;AAEA,SAAS,KAAT,QAAsB,qBAAtB;AACA,SAAS,aAAT,QAA8B,uBAA9B;AACA,SAAS,SAAT,QAA0B,kCAA1B;AACA,SAAS,oBAAT,QAAqC,2BAArC;AA6BA,OAAM,SAAU,YAAV,CACJ,QADI,EAC2B;AAE/B,MAAM,gBAAgB,GAAG,cAAc,CAAC,QAAD,CAAvC;AACA,EAAA,SAAS,CACP,gBAAgB,CAAC,YADV,EAEP,EAFO,CAAT;MAGI,YAAA,GAAA,gBAAA,CAAA,Y;MAAA,GAAA,GAAA,gBAAA,CAAA,G;;MACA,CAAA,YAAA,CAAA,GAAA,CAAA,GAAA,C,EAAA;AAGI,IAAA,YAAY,CAAA,GAAZ,CAAsB,GAAtB,EAAsB,gBAAgB,CAA1B,OAAZ;AAER;;MACE,OAAA,GAAA,oBAAsB,CAAA,KAAA,CAAA,WAAA,CAA0B,UAAA,WAAA,EAAA;AACjD,WAAA,gBAAA,CAAA,MAAA,CAAA,UAAA,OAAA,EAAA;AAEK,MAAA,gBAAU,CAAA,YAAV,CACJ,GADI,CACE,gBACJ,CAAA,GAFE,EAED,OAFC;AAGA,MAAA,WAAO;AACL,KANP,CAAA;GADuB,E,CAQhB,gB,CARgB,CAAA,EAQF,YAAA;AAAA,WAAA,YAAA,CAAA,GAAA,CAAA,GAAA,CAAA;AAAA,GARE,EAQF,YAAA;AAAA,WAAA,YAAA,CAAA,GAAA,CAAA,GAAA,CAAA;AAAA,GARE,C;;MASlB,MAAG,GAAA,KAAA,CAAA,OAAA,C;;AACL,SACC,KAAA,CAAA,OAAA,CAAiB,YAEpB;AAII,WAAM;AAEL,MAAA,IAAK,EAAC,MAAO,CAAC,IAFT;AAGV,MAAA,aAAO,EAAA,MAAA,CAAA,aAHG;AAIR,MAAA,KAAI,EAAE,aAAW,CAAA,MAAA;AAJT,KAAN;GAND,E,CAYD,M,CAZC,CADD;AAcD","sourcesContent":["import * as React from \"react\";\nimport { unwrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport { __use } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { ApolloError } from \"../../errors/index.js\";\nimport type { NetworkStatus } from \"../../core/index.js\";\n\nexport interface UseReadQueryResult<TData = unknown> {\n  /**\n   * An object containing the result of your GraphQL query after it completes.\n   *\n   * This value might be `undefined` if a query results in one or more errors\n   * (depending on the query's `errorPolicy`).\n   */\n  data: TData;\n  /**\n   * If the query produces one or more errors, this object contains either an\n   * array of `graphQLErrors` or a single `networkError`. Otherwise, this value\n   * is `undefined`.\n   *\n   * This property can be ignored when using the default `errorPolicy` or an\n   * `errorPolicy` of `none`. The hook will throw the error instead of setting\n   * this property.\n   */\n  error: ApolloError | undefined;\n  /**\n   * A number indicating the current network state of the query's associated\n   * request. {@link https://github.com/apollographql/apollo-client/blob/d96f4578f89b933c281bb775a39503f6cdb59ee8/src/core/networkStatus.ts#L4 | See possible values}.\n   */\n  networkStatus: NetworkStatus;\n}\n\nexport function useReadQuery<TData>(\n  queryRef: QueryReference<TData>\n): UseReadQueryResult<TData> {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  invariant(\n    internalQueryRef.promiseCache,\n    \"It appears that `useReadQuery` was used outside of `useBackgroundQuery`. \" +\n      \"`useReadQuery` is only supported for use with `useBackgroundQuery`. \" +\n      \"Please ensure you are passing the `queryRef` returned from `useBackgroundQuery`.\"\n  );\n\n  const { promiseCache, key } = internalQueryRef;\n\n  if (!promiseCache.has(key)) {\n    promiseCache.set(key, internalQueryRef.promise);\n  }\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          internalQueryRef.promiseCache!.set(internalQueryRef.key, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef]\n    ),\n    () => promiseCache.get(key)!,\n    () => promiseCache.get(key)!\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}