{"ast":null,"code":"import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\nvar didWarnUncachedGetSnapshot = false; // Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\n\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React[uSESKey]; // Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\n\nexport var useSyncExternalStore = realHook || function (subscribe, getSnapshot, getServerSnapshot) {\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  var value = getSnapshot();\n\n  if ( // DEVIATION: Using __DEV__\n  globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot && // DEVIATION: Not using Object.is because we know our snapshots will never\n  // be exotic primitive values like NaN, which is !== itself.\n  value !== getSnapshot()) {\n    didWarnUncachedGetSnapshot = true; // DEVIATION: Using invariant.error instead of console.error directly.\n\n    globalThis.__DEV__ !== false && invariant.error(58);\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _a = React.useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _a[0].inst,\n      forceUpdate = _a[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  if (canUseLayoutEffect) {\n    // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n    // which may seem like a conditional hook, but this code ends up behaving\n    // unconditionally (one way or the other) because canUseLayoutEffect is\n    // constant.\n    React.useLayoutEffect(function () {\n      Object.assign(inst, {\n        value: value,\n        getSnapshot: getSnapshot\n      }); // Whenever getSnapshot or subscribe changes, we need to check in the\n      // commit phase if there was an interleaved mutation. In concurrent mode\n      // this can happen all the time, but even in synchronous mode, an earlier\n      // effect may have mutated the store.\n\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }, [subscribe, value, getSnapshot]);\n  } else {\n    Object.assign(inst, {\n      value: value,\n      getSnapshot: getSnapshot\n    });\n  }\n\n  React.useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    } // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(function handleStoreChange() {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    });\n  }, [subscribe]);\n  return value;\n};\n\nfunction checkIfSnapshotChanged(_a) {\n  var value = _a.value,\n      getSnapshot = _a.getSnapshot;\n\n  try {\n    return value !== getSnapshot();\n  } catch (_b) {\n    return true;\n  }\n}","map":{"version":3,"sources":["../../../src/react/hooks/useSyncExternalStore.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,QAA0B,kCAA1B;AACA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AAEA,SAAS,kBAAT,QAAmC,0BAAnC;AAEA,IAAI,0BAA0B,GAAG,KAAjC,C,CASA;AACA;AACA;;AACA,IAAM,OAAO,GAAG,sBAAhB;AACA,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAD,CAAtB,C,CAEA;AACA;AAEA;;AACA,OAAO,IAAM,oBAAoB,GAC/B,QAAQ,IACP,UAAC,SAAD,EAAY,WAAZ,EAAyB,iBAAzB,EAA0C;AACzC;AACA;AACA;AACA;AACA,MAAM,KAAK,GAAG,WAAW,EAAzB;;AACA,OACE;AACA,EAAA,UAAO,CAAA,OAAP,KAAO,KAAP,IACA,CAAC,0BADD,IAEA;AACA;AACA,EAAA,KAAK,KAAK,WAAW,EANvB,EAOE;AACA,IAAA,0BAA0B,GAAG,IAA7B,CADA,CAEA;;AACA,IAAA,UAAU,CAAA,OAAV,KACE,KADF,IACE,SAAA,CAAA,KAAA,CAAA,EAAA,CADF;AAGD,GAnBwC,CAqBzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACM,MAAA,EAAA,GAA0B,KAAK,CAAC,QAAN,CAAe;AAC7C,IAAA,IAAI,EAAE;AAAE,MAAA,KAAK,EAAA,KAAP;AAAS,MAAA,WAAW,EAAA;AAApB;AADuC,GAAf,CAA1B;AAAA,MAAG,IAAI,GAAA,EAAA,CAAA,CAAA,CAAA,CAAA,IAAP;AAAA,MAAW,WAAW,GAAA,EAAA,CAAA,CAAA,CAAtB,CAnCmC,CAuCzC;AACA;AACA;;;AACA,MAAI,kBAAJ,EAAwB;AACtB;AACA;AACA;AACA;AACA,IAAA,KAAK,CAAC,eAAN,CAAsB,YAAA;AACpB,MAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAAE,QAAA,KAAK,EAAA,KAAP;AAAS,QAAA,WAAW,EAAA;AAApB,OAApB,EADoB,CAEpB;AACA;AACA;AACA;;AACA,UAAI,sBAAsB,CAAC,IAAD,CAA1B,EAAkC;AAChC;AACA,QAAA,WAAW,CAAC;AAAE,UAAA,IAAI,EAAA;AAAN,SAAD,CAAX;AACD;AACF,KAVD,EAUG,CAAC,SAAD,EAAY,KAAZ,EAAmB,WAAnB,CAVH;AAWD,GAhBD,MAgBO;AACL,IAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAAE,MAAA,KAAK,EAAA,KAAP;AAAS,MAAA,WAAW,EAAA;AAApB,KAApB;AACD;;AAED,EAAA,KAAK,CAAC,SAAN,CAAgB,YAAA;AACd;AACA;AACA,QAAI,sBAAsB,CAAC,IAAD,CAA1B,EAAkC;AAChC;AACA,MAAA,WAAW,CAAC;AAAE,QAAA,IAAI,EAAA;AAAN,OAAD,CAAX;AACD,KANa,CAQd;;;AACA,WAAO,SAAS,CAAC,SAAS,iBAAT,GAA0B;AACzC;AACA;AACA;AACA;AAEA;AACA;AACA,UAAI,sBAAsB,CAAC,IAAD,CAA1B,EAAkC;AAChC;AACA,QAAA,WAAW,CAAC;AAAE,UAAA,IAAI,EAAA;AAAN,SAAD,CAAX;AACD;AACF,KAZe,CAAhB;AAaD,GAtBD,EAsBG,CAAC,SAAD,CAtBH;AAwBA,SAAO,KAAP;AACD,CAzFI;;AA2FP,SAAS,sBAAT,CAA0C,EAA1C,EAMC;MALC,KAAK,GAAA,EAAA,CAAA,K;MACL,WAAW,GAAA,EAAA,CAAA,W;;AAKX,MAAI;AACF,WAAO,KAAK,KAAK,WAAW,EAA5B;AACD,GAFD,CAEE,OAAA,EAAA,EAAM;AACN,WAAO,IAAP;AACD;AACF","sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\n\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}