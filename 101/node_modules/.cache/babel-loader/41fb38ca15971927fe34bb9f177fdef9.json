{"ast":null,"code":"import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\"; // Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\n\nexport function equalByQuery(query, _a, _b, variables) {\n  var aData = _a.data,\n      aRest = __rest(_a, [\"data\"]);\n\n  var bData = _b.data,\n      bRest = __rest(_b, [\"data\"]);\n\n  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n    variables: variables\n  });\n}\n\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  var seenSelections = new Set(); // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n\n  return selectionSet.selections.every(function (selection) {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection); // Ignore @skip(if: true) and @include(if: false) fields.\n\n    if (!shouldInclude(selection, context.variables)) return true; // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      var resultKey = resultKeyNameFromField(selection);\n      var aResultChild = aResult && aResult[resultKey];\n      var bResultChild = bResult && bResult[resultKey];\n      var childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      var aChildIsArray = Array.isArray(aResultChild);\n      var bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n\n      if (aChildIsArray && bChildIsArray) {\n        var length_1 = aResultChild.length;\n\n        if (bResultChild.length !== length_1) {\n          return false;\n        }\n\n        for (var i = 0; i < length_1; ++i) {\n          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n    } else {\n      var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n        return equalBySelectionSet(fragment.selectionSet, // Notice that we reuse the same aResult and bResult values here,\n        // since the fragment ...spread does not specify a field name, but\n        // consists of multiple fields (within the fragment's selection set)\n        // that should be applied to the current result value(s).\n        aResult, bResult, context);\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(selection) {\n  return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\n\nfunction directiveIsNonreactive(dir) {\n  return dir.name.value === \"nonreactive\";\n}","map":{"version":3,"sources":["../../src/core/equalByQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import equal from \"@wry/equality\";\n\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { ApolloQueryResult, OperationVariables } from \"./types.js\";\n\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getFragmentFromSelection,\n  getMainDefinition,\n  isField,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(\n  query: DocumentNode,\n  { data: aData, ...aRest }: Partial<ApolloQueryResult<unknown>>,\n  { data: bData, ...bRest }: Partial<ApolloQueryResult<unknown>>,\n  variables?: OperationVariables\n): boolean {\n  return (\n    equal(aRest, bRest) &&\n    equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      variables,\n    })\n  );\n}\n\n// Encapsulates the information used by equalBySelectionSet that does not change\n// during the recursion.\ninterface CompareContext<TVariables> {\n  fragmentMap: FragmentMap;\n  variables: TVariables | undefined;\n}\n\nfunction equalBySelectionSet(\n  selectionSet: SelectionSetNode,\n  aResult: any,\n  bResult: any,\n  context: CompareContext<OperationVariables>\n): boolean {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  const seenSelections = new Set<SelectionNode>();\n\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every((selection) => {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      const resultKey = resultKeyNameFromField(selection);\n      const aResultChild = aResult && aResult[resultKey];\n      const bResultChild = bResult && bResult[resultKey];\n      const childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      const aChildIsArray = Array.isArray(aResultChild);\n      const bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        const length = aResultChild.length;\n        if (bResultChild.length !== length) {\n          return false;\n        }\n        for (let i = 0; i < length; ++i) {\n          if (\n            !equalBySelectionSet(\n              childSelectionSet,\n              aResultChild[i],\n              bResultChild[i],\n              context\n            )\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return equalBySelectionSet(\n        childSelectionSet,\n        aResultChild,\n        bResultChild,\n        context\n      );\n    } else {\n      const fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n\n        return equalBySelectionSet(\n          fragment.selectionSet,\n          // Notice that we reuse the same aResult and bResult values here,\n          // since the fragment ...spread does not specify a field name, but\n          // consists of multiple fields (within the fragment's selection set)\n          // that should be applied to the current result value(s).\n          aResult,\n          bResult,\n          context\n        );\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(\n  selection:\n    | FieldNode\n    | InlineFragmentNode\n    | FragmentSpreadNode\n    | FragmentDefinitionNode\n): boolean {\n  return (\n    !!selection.directives && selection.directives.some(directiveIsNonreactive)\n  );\n}\n\nfunction directiveIsNonreactive(dir: DirectiveNode): boolean {\n  return dir.name.value === \"nonreactive\";\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}