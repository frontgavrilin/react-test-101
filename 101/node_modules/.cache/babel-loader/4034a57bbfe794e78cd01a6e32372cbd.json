{"ast":null,"code":"import { newInvariantError } from \"../globals/index.js\";\nimport { isNonNullObject } from \"../common/objects.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\nexport function makeReference(id) {\n  return {\n    __ref: String(id)\n  };\n}\nexport function isReference(obj) {\n  return Boolean(obj && typeof obj === \"object\" && typeof obj.__ref === \"string\");\n}\nexport function isDocumentNode(value) {\n  return isNonNullObject(value) && value.kind === \"Document\" && Array.isArray(value.definitions);\n}\n\nfunction isStringValue(value) {\n  return value.kind === \"StringValue\";\n}\n\nfunction isBooleanValue(value) {\n  return value.kind === \"BooleanValue\";\n}\n\nfunction isIntValue(value) {\n  return value.kind === \"IntValue\";\n}\n\nfunction isFloatValue(value) {\n  return value.kind === \"FloatValue\";\n}\n\nfunction isVariable(value) {\n  return value.kind === \"Variable\";\n}\n\nfunction isObjectValue(value) {\n  return value.kind === \"ObjectValue\";\n}\n\nfunction isListValue(value) {\n  return value.kind === \"ListValue\";\n}\n\nfunction isEnumValue(value) {\n  return value.kind === \"EnumValue\";\n}\n\nfunction isNullValue(value) {\n  return value.kind === \"NullValue\";\n}\n\nexport function valueToObjectRepresentation(argObj, name, value, variables) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    var nestedArgObj_1 = {};\n    value.fields.map(function (obj) {\n      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n    });\n    argObj[name.value] = nestedArgObj_1;\n  } else if (isVariable(value)) {\n    var variableValue = (variables || {})[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(function (listValue) {\n      var nestedArgArrayObj = {};\n      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n      return nestedArgArrayObj[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw newInvariantError(81, name.value, value.kind);\n  }\n}\nexport function storeKeyNameFromField(field, variables) {\n  var directivesObj = null;\n\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(function (directive) {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(function (_a) {\n          var name = _a.name,\n              value = _a.value;\n          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n        });\n      }\n    });\n  }\n\n  var argObj = null;\n\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n          value = _a.value;\n      return valueToObjectRepresentation(argObj, name, value, variables);\n    });\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\"connection\", \"include\", \"skip\", \"client\", \"rest\", \"export\", \"nonreactive\"];\nexport var getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n  if (args && directives && directives[\"connection\"] && directives[\"connection\"][\"key\"]) {\n    if (directives[\"connection\"][\"filter\"] && directives[\"connection\"][\"filter\"].length > 0) {\n      var filterKeys = directives[\"connection\"][\"filter\"] ? directives[\"connection\"][\"filter\"] : [];\n      filterKeys.sort();\n      var filteredArgs_1 = {};\n      filterKeys.forEach(function (key) {\n        filteredArgs_1[key] = args[key];\n      });\n      return \"\".concat(directives[\"connection\"][\"key\"], \"(\").concat(stringify(filteredArgs_1), \")\");\n    } else {\n      return directives[\"connection\"][\"key\"];\n    }\n  }\n\n  var completeFieldName = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    var stringifiedArgs = stringify(args);\n    completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(function (key) {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += \"@\".concat(key, \"(\").concat(stringify(directives[key]), \")\");\n      } else {\n        completeFieldName += \"@\".concat(key);\n      }\n    });\n  }\n\n  return completeFieldName;\n}, {\n  setStringify: function (s) {\n    var previous = stringify;\n    stringify = s;\n    return previous;\n  }\n}); // Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\n\nvar stringify = function defaultStringify(value) {\n  return JSON.stringify(value, stringifyReplacer);\n};\n\nfunction stringifyReplacer(_key, value) {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value).sort().reduce(function (copy, key) {\n      copy[key] = value[key];\n      return copy;\n    }, {});\n  }\n\n  return value;\n}\n\nexport function argumentsObjectFromField(field, variables) {\n  if (field.arguments && field.arguments.length) {\n    var argObj_1 = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n          value = _a.value;\n      return valueToObjectRepresentation(argObj_1, name, value, variables);\n    });\n    return argObj_1;\n  }\n\n  return null;\n}\nexport function resultKeyNameFromField(field) {\n  return field.alias ? field.alias.value : field.name.value;\n}\nexport function getTypenameFromResult(result, selectionSet, fragmentMap) {\n  var fragments;\n\n  for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n    var selection = _a[_i];\n\n    if (isField(selection)) {\n      if (selection.name.value === \"__typename\") {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n\n  if (typeof result.__typename === \"string\") {\n    return result.__typename;\n  }\n\n  if (fragments) {\n    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {\n      var selection = fragments_1[_b];\n      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n\n      if (typeof typename === \"string\") {\n        return typename;\n      }\n    }\n  }\n}\nexport function isField(selection) {\n  return selection.kind === \"Field\";\n}\nexport function isInlineFragment(selection) {\n  return selection.kind === \"InlineFragment\";\n}","map":{"version":3,"sources":["../../../src/utilities/graphql/storeUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n  SelectionSetNode,\n  DocumentNode,\n  FragmentSpreadNode,\n} from \"graphql\";\n\nimport { isNonNullObject } from \"../common/objects.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\n\nexport interface Reference {\n  readonly __ref: string;\n}\n\nexport function makeReference(id: string): Reference {\n  return { __ref: String(id) };\n}\n\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(\n    obj && typeof obj === \"object\" && typeof obj.__ref === \"string\"\n  );\n}\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\n/**\n * Workaround for a TypeScript quirk:\n * types per default have an implicit index signature that makes them\n * assignable to `StoreObject`.\n * interfaces do not have that implicit index signature, so they cannot\n * be assigned to `StoreObject`.\n * This type just maps over a type or interface that is passed in,\n * implicitly adding the index signature.\n * That way, the result can be assigned to `StoreObject`.\n *\n * This is important if some user-defined interface is used e.g.\n * in cache.modify, where the `toReference` method expects a\n * `StoreObject` as input.\n */\nexport type AsStoreObject<T extends { __typename?: string }> = {\n  [K in keyof T]: T[K];\n};\n\nexport function isDocumentNode(value: any): value is DocumentNode {\n  return (\n    isNonNullObject(value) &&\n    (value as DocumentNode).kind === \"Document\" &&\n    Array.isArray((value as DocumentNode).definitions)\n  );\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === \"StringValue\";\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === \"BooleanValue\";\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === \"IntValue\";\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === \"FloatValue\";\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === \"Variable\";\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === \"ObjectValue\";\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === \"ListValue\";\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === \"EnumValue\";\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === \"NullValue\";\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map((obj) =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables)\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map((listValue) => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw newInvariantError(\n      `The inline argument \"%s\" of kind \"%s\"` +\n        \"is not supported. Use variables instead of inline arguments to \" +\n        \"overcome this limitation.\",\n      name.value,\n      (value as any).kind\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach((directive) => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables\n          )\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables)\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  \"connection\",\n  \"include\",\n  \"skip\",\n  \"client\",\n  \"rest\",\n  \"export\",\n  \"nonreactive\",\n];\n\nexport const getStoreKeyName = Object.assign(\n  function (\n    fieldName: string,\n    args?: Record<string, any> | null,\n    directives?: Directives\n  ): string {\n    if (\n      args &&\n      directives &&\n      directives[\"connection\"] &&\n      directives[\"connection\"][\"key\"]\n    ) {\n      if (\n        directives[\"connection\"][\"filter\"] &&\n        (directives[\"connection\"][\"filter\"] as string[]).length > 0\n      ) {\n        const filterKeys =\n          directives[\"connection\"][\"filter\"] ?\n            (directives[\"connection\"][\"filter\"] as string[])\n          : [];\n        filterKeys.sort();\n\n        const filteredArgs = {} as { [key: string]: any };\n        filterKeys.forEach((key) => {\n          filteredArgs[key] = args[key];\n        });\n\n        return `${directives[\"connection\"][\"key\"]}(${stringify(filteredArgs)})`;\n      } else {\n        return directives[\"connection\"][\"key\"];\n      }\n    }\n\n    let completeFieldName: string = fieldName;\n\n    if (args) {\n      // We can't use `JSON.stringify` here since it's non-deterministic,\n      // and can lead to different store key names being created even though\n      // the `args` object used during creation has the same properties/values.\n      const stringifiedArgs: string = stringify(args);\n      completeFieldName += `(${stringifiedArgs})`;\n    }\n\n    if (directives) {\n      Object.keys(directives).forEach((key) => {\n        if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n        if (directives[key] && Object.keys(directives[key]).length) {\n          completeFieldName += `@${key}(${stringify(directives[key])})`;\n        } else {\n          completeFieldName += `@${key}`;\n        }\n      });\n    }\n\n    return completeFieldName;\n  },\n  {\n    setStringify(s: typeof stringify) {\n      const previous = stringify;\n      stringify = s;\n      return previous;\n    },\n  }\n);\n\n// Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\nlet stringify = function defaultStringify(value: any): string {\n  return JSON.stringify(value, stringifyReplacer);\n};\n\nfunction stringifyReplacer(_key: string, value: any): any {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value)\n      .sort()\n      .reduce(\n        (copy, key) => {\n          copy[key] = value[key];\n          return copy;\n        },\n        {} as Record<string, any>\n      );\n  }\n  return value;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables?: Record<string, any>\n): Object | null {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables)\n    );\n    return argObj;\n  }\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap\n): string | undefined {\n  let fragments: undefined | Array<InlineFragmentNode | FragmentSpreadNode>;\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === \"__typename\") {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n  if (typeof result.__typename === \"string\") {\n    return result.__typename;\n  }\n  if (fragments) {\n    for (const selection of fragments) {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap\n      );\n      if (typeof typename === \"string\") {\n        return typename;\n      }\n    }\n  }\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === \"Field\";\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode\n): selection is InlineFragmentNode {\n  return selection.kind === \"InlineFragment\";\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}