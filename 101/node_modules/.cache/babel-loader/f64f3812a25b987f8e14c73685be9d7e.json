{"ast":null,"code":"import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, isArray } from \"./helpers.js\"; // Mapping from JSON-encoded KeySpecifier strings to associated information.\n\nvar specifierInfoCache = Object.create(null);\n\nfunction lookupSpecifierInfo(spec) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  var cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null));\n}\n\nexport function keyFieldsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n    var extract = function (from, key) {\n      return context.readField(key, from);\n    };\n\n    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n      var extracted = extractKeyPath(context.storeObject, schemaKeyPath, // Using context.readField to extract paths from context.storeObject\n      // allows the extraction to see through Reference objects and respect\n      // custom read functions.\n      extract);\n\n      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {\n        // If context.storeObject fails to provide a value for the requested\n        // path, fall back to the raw result object, if it has a top-level key\n        // matching the first key in the path (schemaKeyPath[0]). This allows\n        // key fields included in the written data to be saved in the cache\n        // even if they are not selected explicitly in context.selectionSet.\n        // Not being mentioned by context.selectionSet is convenient here,\n        // since it means these extra fields cannot be affected by field\n        // aliasing, which is why we can use extractKey instead of\n        // context.readField for this extraction.\n        extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n      }\n\n      invariant(extracted !== void 0, 4, schemaKeyPath.join(\".\"), object);\n      return extracted;\n    });\n    return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n  });\n} // The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\n\nexport function keyArgsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n    var field = _a.field,\n        variables = _a.variables,\n        fieldName = _a.fieldName;\n    var collected = collectSpecifierPaths(specifier, function (keyPath) {\n      var firstKey = keyPath[0];\n      var firstChar = firstKey.charAt(0);\n\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          var directiveName_1 = firstKey.slice(1); // If the directive appears multiple times, only the first\n          // occurrence's arguments will be used. TODO Allow repetition?\n          // TODO Cache this work somehow, a la aliasMap?\n\n          var d = field.directives.find(function (d) {\n            return d.name.value === directiveName_1;\n          }); // Fortunately argumentsObjectFromField works for DirectiveNode!\n\n          var directiveArgs = d && argumentsObjectFromField(d, variables); // For directives without arguments (d defined, but directiveArgs ===\n          // null), the presence or absence of the directive still counts as\n          // part of the field key, so we return null in those cases. If no\n          // directive with this name was found for this field (d undefined and\n          // thus directiveArgs undefined), we return undefined, which causes\n          // this value to be omitted from the key object returned by\n          // collectSpecifierPaths.\n\n          return directiveArgs && extractKeyPath(directiveArgs, // If keyPath.length === 1, this code calls extractKeyPath with an\n          // empty path, which works because it uses directiveArgs as the\n          // extracted value.\n          keyPath.slice(1));\n        } // If the key started with @ but there was no corresponding directive,\n        // we want to omit this value from the key object, not fall through to\n        // treating @whatever as a normal argument name.\n\n\n        return;\n      }\n\n      if (firstChar === \"$\") {\n        var variableName = firstKey.slice(1);\n\n        if (variables && hasOwn.call(variables, variableName)) {\n          var varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        } // If the key started with $ but there was no corresponding variable, we\n        // want to omit this value from the key object, not fall through to\n        // treating $whatever as a normal argument name.\n\n\n        return;\n      }\n\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n    var suffix = JSON.stringify(collected); // If no arguments were passed to this field, and it didn't have any other\n    // field key contributions from directives or variables, hide the empty\n    // :{} suffix from the field key. However, a field passed no arguments can\n    // still end up with a non-empty :{...} suffix if its key configuration\n    // refers to directives or variables.\n\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n\n    return fieldName;\n  });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  var merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce(function (collected, path) {\n    var _a;\n\n    var toMerge = extractor(path);\n\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (var i = path.length - 1; i >= 0; --i) {\n        toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n      }\n\n      collected = merger.merge(collected, toMerge);\n    }\n\n    return collected;\n  }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n  var info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    var paths_1 = info.paths = [];\n    var currentPath_1 = [];\n    spec.forEach(function (s, i) {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach(function (p) {\n          return paths_1.push(currentPath_1.concat(p));\n        });\n        currentPath_1.length = 0;\n      } else {\n        currentPath_1.push(s);\n\n        if (!isArray(spec[i + 1])) {\n          paths_1.push(currentPath_1.slice(0));\n          currentPath_1.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths;\n}\n\nfunction extractKey(object, key) {\n  return object[key];\n}\n\nexport function extractKeyPath(object, path, extract) {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key) {\n    return isArray(obj) ? obj.map(function (child) {\n      return reducer(child, key);\n    }) : obj && extract(obj, key);\n  }, object));\n}\n\nfunction normalize(value) {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize);\n    }\n\n    return collectSpecifierPaths(Object.keys(value).sort(), function (path) {\n      return extractKeyPath(value, path);\n    });\n  }\n\n  return value;\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/key-extractor.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\n\nimport { hasOwn, isArray } from \"./helpers.js\";\nimport type {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return (\n    specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null))\n  );\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj) ?\n          obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}