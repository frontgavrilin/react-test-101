{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from \"react\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\"; // The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\n\nvar EAGER_METHODS = [\"refetch\", \"reobserve\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"subscribeToMore\"];\nexport function useLazyQuery(query, options) {\n  var _a;\n\n  var execOptionsRef = React.useRef();\n  var optionsRef = React.useRef();\n  var queryRef = React.useRef();\n  var merged = mergeOptions(options, execOptionsRef.current || {});\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query; // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n\n  optionsRef.current = merged;\n  queryRef.current = document;\n  var internalState = useInternalState(useApolloClient(options && options.client), document);\n  var useQueryResult = internalState.useQuery(__assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  }));\n  var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy || internalState.getDefaultFetchPolicy();\n  var result = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current\n  }); // We use useMemo here to make sure the eager methods have a stable identity.\n\n  var eagerMethods = React.useMemo(function () {\n    var eagerMethods = {};\n\n    var _loop_1 = function (key) {\n      var method = result[key];\n\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null); // Only the first time populating execOptionsRef.current matters here.\n\n          internalState.forceUpdateState();\n        } // @ts-expect-error this is just too generic to type\n\n\n        return method.apply(this, arguments);\n      };\n    };\n\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n\n      _loop_1(key);\n    }\n\n    return eagerMethods;\n  }, []);\n  Object.assign(result, eagerMethods);\n  var execute = React.useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = internalState.executeQuery(__assign(__assign({}, options), {\n      skip: false\n    })).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    }); // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n\n    promise.catch(function () {});\n    return promise;\n  }, []);\n  return [execute, result];\n}","map":{"version":3,"sources":["../../../src/react/hooks/useLazyQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"react\";\n\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryResult,\n} from \"../types/types.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"subscribeToMore\",\n] as const;\n\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = merged;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current,\n  });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current =\n        executeOptions ?\n          {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = internalState\n        .executeQuery({ ...options, skip: false })\n        .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    []\n  );\n\n  return [execute, result];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}