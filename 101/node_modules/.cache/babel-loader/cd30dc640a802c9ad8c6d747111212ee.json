{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\n\nfunction identity(document) {\n  return document;\n}\n\nvar DocumentTransform =\n/** @class */\nfunction () {\n  function DocumentTransform(transform, options) {\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n\n    this.resultCache = canUseWeakSet ? new WeakSet() : new Set();\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, function (key) {\n        return {\n          key: key\n        };\n      });\n    }\n  } // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n\n\n  DocumentTransform.prototype.getCacheKey = function (document) {\n    return [document];\n  };\n\n  DocumentTransform.identity = function () {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, {\n      cache: false\n    });\n  };\n\n  DocumentTransform.split = function (predicate, left, right) {\n    if (right === void 0) {\n      right = DocumentTransform.identity();\n    }\n\n    return new DocumentTransform(function (document) {\n      var documentTransform = predicate(document) ? left : right;\n      return documentTransform.transformDocument(document);\n    }, // Reasonably assume both `left` and `right` transforms handle their own caching\n    {\n      cache: false\n    });\n  };\n\n  DocumentTransform.prototype.transformDocument = function (document) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    var cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n    var transformedDocument = this.transform(document);\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  };\n\n  DocumentTransform.prototype.concat = function (otherTransform) {\n    var _this = this;\n\n    return new DocumentTransform(function (document) {\n      return otherTransform.transformDocument(_this.transformDocument(document));\n    }, // Reasonably assume both transforms handle their own caching\n    {\n      cache: false\n    });\n  };\n\n  DocumentTransform.prototype.getStableCacheEntry = function (document) {\n    if (!this.stableCacheKeys) return;\n    var cacheKeys = this.getCacheKey(document);\n\n    if (cacheKeys) {\n      invariant(Array.isArray(cacheKeys), 65);\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  };\n\n  return DocumentTransform;\n}();\n\nexport { DocumentTransform };","map":{"version":3,"sources":["../../../src/utilities/graphql/DocumentTransform.ts"],"names":[],"mappings":"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","sourcesContent":["import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  cache?: boolean;\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  private stableCacheKeys:\n    | Trie<{ key: DocumentTransformCacheKey; value?: DocumentNode }>\n    | undefined;\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return new DocumentTransform(\n      (document) => {\n        const documentTransform = predicate(document) ? left : right;\n\n        return documentTransform.transformDocument(document);\n      },\n      // Reasonably assume both `left` and `right` transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, (key) => ({ key }));\n    }\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n\n    const transformedDocument = this.transform(document);\n\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform) {\n    return new DocumentTransform(\n      (document) => {\n        return otherTransform.transformDocument(\n          this.transformDocument(document)\n        );\n      },\n      // Reasonably assume both transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  getStableCacheEntry(document: DocumentNode) {\n    if (!this.stableCacheKeys) return;\n    const cacheKeys = this.getCacheKey(document);\n    if (cacheKeys) {\n      invariant(\n        Array.isArray(cacheKeys),\n        \"`getCacheKey` must return an array or undefined\"\n      );\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}